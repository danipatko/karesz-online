/* 
BASE CONCEPT:
Code is being sent to the server, that compiles it to an array of instructions
then it sends back to the frontend where it gets executed
*/

// Concept: easily readable and parseable instructions that can be generated by various programming languages
// One instruction consist of a command (key) and a value of an integer or an enum
export interface instruction {
    command:string,
    value?:any
}
// coordinate defined by the x and y axis
export interface point {
    x: number,
    y: number
}
// some stats
interface stats {
    numSteps:number,
    numTurns:number,
    numWallchecks:number,
    numCrashes:number,
    numPickups:number,
    numColor:number,
    rocksCollected:number,
    rocksPlaced:number
}

// Basic turning directions
enum direction {
    right = 1,
    left = -1
};
// rotation degrees
export enum rotation {
    up = 0,
    right = 1,
    down = 2,
    left = 3
}
// possible field values in matrix
export enum field {
    empty = 0,
    wall = 1,
    rock_black = 2,
    rock_red = 3,
    rock_green = 4,
    rock_yellow = 5
}
// karesz map
class map {
    sizeX:number;
    sizeY:number;
    // players?:Array<karesz>;  //TODO: multiplayer
    matrix:Array<Array<field>>;

    constructor(sizeX:number=10, sizeY:number=10, /*players?:Array<karesz>*/){
        this.sizeX = sizeX;
        this.sizeY = sizeY;
        // this.players = players;
        this.matrix = Array(sizeY).fill(field.empty).map(() => Array(sizeX).fill(field.empty));
    }

    _print = (kp?:point):void => {
        // iter vertically
        for (let y = 0; y < this.matrix.length; y++) 
            // one line
            console.log(y + ': ' + this.matrix[y].map((v, x) => kp && x == kp.x && y == kp.y ? 'K' : v ).join(' ') + '\n');
        console.log('-----------------------');
    }

    /**
     * Populate map contents from a string lol
     */
    load = (mapStr:string):void => {
        const arr = mapStr.split('\n');
        for (let y = 0; y < arr.length; y++)
            this.matrix[y] = arr[y].split('\t').map(x => parseInt(x));
    }
}

const modulo = (a:number, b:number):number => a < 0 ? b + a%b : a%b;

export class karesz extends map {
    // Default parameters
    position:point;
    rotation:rotation;
    stats:stats;
    errorCallback:Function;
    steps:Array<instruction> = [];

    // Initialization: starting position and rotation
    constructor(startPosition:point={x:0, y:0}, startRotation:rotation=rotation.up, errorCallback:Function=(e:any) => console.log(e), sizeX:number=10, sizeY:number=10){
        super(sizeX, sizeY);
        this.position = startPosition;
        this.rotation = startRotation;
        this.stats = { numColor:0, numCrashes:0, numPickups:0, numSteps:0, numTurns:0, numWallchecks:0, rocksCollected:0, rocksPlaced:0 };
        this.errorCallback = errorCallback;
        this.matrix = Array(sizeX).fill(field.empty).map(() => Array(sizeY).fill(field.empty));
    }

    private isRock = (f:field):boolean => f >= 2 && f <= 5;

    private inBounds = (p:point):boolean => p && (p.x < this.sizeX && p.x >= 0) && (p.y < this.sizeY && p.y >= 0);

    private print = ():void => {
        for (let y = 0; y < this.sizeY; y++) 
            console.log(y + ': ' + this.matrix.map(x => x[y]).join(' ') + '\n');
        console.log('-----------------------');
    }

    /**
     * Check if can step to a point
     */
    private isFieldClear = (p:point):boolean => 
        this.inBounds(p) && (this.matrix[p.x][p.y] == field.empty || this.isRock(this.matrix[p.x][p.y]));

    private forward = (size:number=1):point => {
        switch(this.rotation) {
            case rotation.up:
                return { x:this.position.x, y: this.position.y - size };
            case rotation.down:
                return { x:this.position.x, y: this.position.y + size };
            case rotation.right:
                return { x:this.position.x + size, y: this.position.y };
            case rotation.left:
                return { x:this.position.x - size, y: this.position.y }
        }
    }
    
    err = (msg:string) => {
        this.steps.push({ command:'ERROR', value:msg });
        this.errorCallback(msg);
    }

    /**
     * Take n steps forward
     */
    step = (n:number=1):void => {
        const targ = this.forward(n);
        if(! this.isFieldClear(targ)) { this.err('Cannot step forward'); return; }
        
        this.position = targ;
        this.steps.push({ command:'step', value:this.position });
        this.stats.numSteps++;
    }

    /**
     * Turn right (1) or left (-1)
     */
    turn = (direction:direction):void => {
        this.rotation = modulo(this.rotation + direction, 4);
        this.steps.push({ command:'turn', value:this.rotation });
        this.stats.numTurns++;
    }

    /**
     * Get the content of the field under
     */
    whatIsUnder = ():field => 
        this.matrix[this.position.x][this.position.y];
    
    /**
     * Check if rock is at player position
     */
    isRockUnder = ():boolean => this.isRock(this.matrix[this.position.x][this.position.y]);

    /**
     * If any, pick up rock from player position
     */
    pickUpRock = ():void => {
        if(! this.isRockUnder()){
            this.err('No rock was below');
            return;
        }

        this.matrix[this.position.x][this.position.y] = field.empty;
        this.steps.push({ command:'pickup', value: this.position });
        this.stats.rocksCollected++;
    }

    //TODO: color
    placeRock = (color?:field):void => {
        if(this.isRockUnder()){
            this.err('Cannot place rock');
            return;
        }
        
        this.matrix[this.position.x][this.position.y] = color || field.rock_black;
        this.steps.push({ command:'place', value: { position: this.position, color: color || field.rock_black }});
        this.stats.rocksPlaced++;
    }

    /**
     * Check what is on the field in front of karesz
     */
    whatIsInFront = ():field => {
        const { x, y } = this.forward();
        return this.matrix[x][y];
    }

    status = ():void => {
        console.log(
        `           --- STATS --- 
        position: x.${this.position.x} | y.${this.position.y}
        rotation: ${this.rotation}
        under: ${this.whatIsUnder()}
        front: ${this.whatIsInFront()}
        stats: ${JSON.stringify(this.stats)}
        `);
        this.print();
    }

    // -------- "Util" functions to match Molnár's karesz --------

    Lépj = ():void => this.step();
    Fordulj_jobbra = ():void => this.turn(direction.right);
    Fordulj_balra = ():void => this.turn(direction.left);
    Vegyél_fel_egy_kavicsot = ():void => this.pickUpRock();
    Tegyél_le_egy_kavicsot = (color?:field):void => this.placeRock(color);
    Északra_néz = ():boolean => this.rotation == rotation.up;
    Délre_néz = ():boolean => this.rotation == rotation.down;
    Keletre_néz = ():boolean => this.rotation == rotation.left;
    Nyugatra_néz = ():boolean => this.rotation == rotation.right;
    Merre_néz = ():rotation => this.rotation;
    Van_e_itt_kavics = ():boolean => this.isRockUnder();
    Mi_van_alattam = ():field => this.whatIsUnder();
    Van_e_előttem_fal = ():boolean => this.whatIsInFront() == field.wall;
    Kilépek_e_a_pályáról = ():boolean => this.inBounds(this.forward());
}

// Called on run - execute array of instructions
export const run = (instructions:Array<instruction>):any => {

    console.log('CALLED');
    
    return undefined;
};
